# 11.0 - Hash Tables

In this lecture we'll be looking at hashing, another approach to symbol tables that can also be very effective.

When we left red-black BSTs, we were in a position where we could obtain logarithmic performance for a large range of operations, including search, insert and delete.

Can we do better?

The answer to that question turns out to be yes, we can do better. However, to do so, we need to look at a different way of accessing the data, which also doesn't allow us to perform ordered operations like rank and select.

## Hashing - Basic Plan

The basic idea behind a hash table is that we will be saving items in a key-indexed table (which means that the index is a function of the key). The resulting table is, in many ways, similar to an array.

The **hash function** is a method for computing our array index from the key we are given.

### Issues

What issues do we need to solve to be able to implement the above. Well:

1. **Hash Function** - We need to work out how to compute the hash function
2. **Equality Test** - Rather than compares, we'll be doing equality tests, so we need to ensure we have a method which allows us to do that.
3. **Collision Resolution** - Finally, we'll need to have an algorithm and data structure that can handle two keys that hash to the same array index.

None of these are particularly difficult to solve, but we do need to address all of them to be able to work effectively.

### Classic Space-Time Tradeoff

The hash table is potentially the most classic version of the space-time tradeoff. If we had infinite space for instance, we could just use the key we're given as the index and work with that.

On the other hand, if we had no time limitation, its our collision resolution that becomes trivial. We can just store the items in an array and do a sequential search when we do a lookup.

In the real world, we need to find a way to balance these concerns. That's where hashing comes in.