# 4.3 - Shellsort

The third sorting mechanism we'll have a look at is the shellsort, which is more complex than our previous two sorts. (I also don't think I've heard of it before.) It is also one of the oldest sorting algorithms, having been invented in 1959.

## Algorithm

The motivation behind the shellsort is that the insertion sort is essentially inefficient because we move entries only one step at a time when in reality we'd have to move them several steps.

We do this using a procedure called **h-sorting**. An h-sorted array is an array of h interleaved sorted sequences. For example, the array below is h-sorted for h = 4, because all the sub-arrays taken using every 4th element are sorted:

L E E A M H L E P S O L T S X R
L-------M-------P-------T------
--E-------H-------S-------S----
----E-------L-------O-------X--
------A-------E-------L-------R

The shell-sort mechanism than h-sorts the array for decreasing sequence of values of h. For example:

Input:   S H E L L S O R T E X A M P L E
13-sort: P H E L L S O R T E X A M S L E
4-sort:  L E E A M H L E P S O L T S X R
1-sort:  A E E E H L L L M O P R S S T X

### H-sorting mechanism

Our first question then, is how do we h-sort an array? The answer is simple, we just use an insertion sort with a stride length of h. Why do we use an insertion sort?
* For big increments => small subarrays, so insertion sort is quick
* For small increments => our array will be nearly in order

The second fact is  made through by a mathematical proposition, namely:

> A g-sorted array remains g-sorted after h-sorting it.
> 
Proving this fact is surprisingly complex, but the fact that its true is what makes shell sort effective.

The next question is what sequence of increments should we sort it in. This is another surprisingly tough question. Options include:
* **Powers of 2** - **NO**. Not comparing odd indices to even ones will the 1-sort has major potential performance issues
* **Powers of 2 minus 1** - Proposed by Shell himself. Does an ok job
* **3x + 1** - Proposed by Knuth. Easy to compute, and does a good job.

However, finding the optimal sequence is a difficult research problem which has still not been resolved. Sedgewick (the lecturer) himself found an effective sequence (which starts 1, 5, 19, 41, 109...) which is hard to beat empirically. However, nobody knows if it is the best option.